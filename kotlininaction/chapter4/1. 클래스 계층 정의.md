# [클래스 계층 정의]

## 1. 코틀린 인터페이스

코틀린 인터페이스는 Java8 인터페이스와 비슷하다.

코틀린 인터페이스 안에는 추상 메서드 뿐만 아니라 구현이 있는 메서드도 정의할 수 있다.

(Java8 디폴트 메서드와 유사)

하지만 인터페이스에는 아무런 상태(필드)가 들어갈 수 없다.


```kotlin
interface Clickable {
    fun click()
}
```

다음은 인터페이스 구현을 알아보도록 하자.

```kotlin
class Button: Clickable {
    override fun click() = println("I was clicked")
}

Button().click()
```

- 자바에서는 `extends`와 `implements` 키워드를 사용하지만, 코틀린은 `:` 문자를 활용한다.
- 자바와 마찬가지로 다중 구현이 가능하지만, 확장은 단 하나의 클래스만 가능하다.
- 자바와 달리 코틀린에서는 `override` 변경자를 꼭 사용해야 한다.
- `override` 변경자는 실수로 상위 클래스의 메서드를 오버라이드하는 경우를 방지한다.
- 상위 클래스에 있는 메서드와 시그니처가 같은 메서드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 불가능하다.

```kotlin
interface Clickable {
    fun click() // 일반 메서드
    fun showOff() = println("I'm clickable!!!") // 디폴트 구현이 있는 메서드
}
```

- `click` 메서드의 경우 구현을 제공해야 한다.
- `showOff` 메서드의 경우 정의를 생략해서 디폴트 구현을 사용할 수 있다.

```kotlin
interface Focusable {
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")
    fun showOff() = println("I'm focusable!!!")
}
```

- 한 클래스에 이렇게 **두 가지 동일한 이름을 가진, 구현이 되어있는 메서드가 존재한다면, 그 어느 쪽도 선택되지 않는다.**
- 클래스가 구현하는 두 상위 인터페이스에 정의된 `showOff` 구현을 대체할 오버라이딩 메서드를 직접 제공하지 않으면, 컴파일 오류가 발생한다.

```kotlin
class Button: Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() {
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

- `Button`은 상속한 두 상위 타입의 `showOff()`메서드를 호출하는 방식으로 구현한다.
- 상위 타입의 구현을 호출할 때는 자바와 마찬가지로 `super` 키워드를 사용한다.
- 하지만 구체적으로 타입을 지정하기 위해선 꺾쇠 괄호 안에 기반 타입을 지정한다.

---

## 2. open, final, abstract 변경자: 기본적으로 final

자바에서는 `final`을 활용하여 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 없다.

이렇게 기본적으로 상속이 가능하면 편리하지만 문제가 생기는 경우가 있다.

**취약한 기반 클래스(fragile base class)** 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.

어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면,

그 클래스의 클라이언트는 **기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드할 위험** 이 있다.

모든 하위 클래스를 분석하는 것은 불가능하므로,

기반 클래스를 변경하는 경우 하위 클래스 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 **취약** 하다.

이에 코틀린은 **"상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라"** 라는 원칙을 따른다.

이는 하위 클래스에서 **오버라이드하게 의도된 클래스와 메서드가 아니라면 모두 `final`로 만들라** 는 의미이다.

코틀린의 클래스와 메서드는 기본적으로 `final`이다.

어떤 클래스의 상속을 허용하기 위해선 `open` 키워드를 클래스 앞에 붙여야 한다.

```kotlin
open class RichButton: Clickable {
    fun disable() // 해당 함수는 파이널. 하위 클래스가 오버라이드할 수 없다.
    open fun animate() {} // 오버라이드 가능
    override fun click() {} // 오버라이드한 메서드는 기본적으로 열려있다.
    final override fun clicked() {} // 오버라이드를 막고자 한다면 final 키워드를 붙인다.
}
```

코틀린도 클래스를 `abstract`로 선언할 수 있다.

`abstract`로 선언한 추상 클래스는 인스턴스화할 수 없다.

추상 크랠스는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드해야만 하는 게 일반적이다.

추상 멤버는 항상 열려있으므로, 추상 멤버 앞에 open 변경자를 명시할 필요는 없다.

```kotlin
abstract class Animated {
    abstract fun animate()
    open fun stopAnimating() {}
    fun animateTwice() {} // 추상 클래스에 속했더라도 비추상메서드는 기본적으로 final 이지만, open으로 선언할 수 있다.
}
```

| 변경자      | 변경자가 붙으면,                       | 설명                                                            |
|----------|---------------------------------|---------------------------------------------------------------|
| final    | 오버라이드할 수 없음                     | 클래스 멤버의 기본 변경자.                                               |
| open     | 오버라이드할 수 없음                     | 반드시 open을 명시해야 오버라이드할 수 있다.                                   |
| abstract | 반드시 오버라이드 해야 함                  | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다.            |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드 하는 중 | 오버라이드 하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다. |

---

## 3. 가시성 변경자: 기본적으로 공개

**가시성 변경자(visibility modifier)** 는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.

어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다.

코틀린의 기본 가시성은 자바와 다르게 아무 변경자가 없는 경우 `public`으로 적용된다.

코틀린은 자바와 달리 패키지 전용 가시성이 없고, 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다. -> **가시성 제어에 활용하지 않는다.**

패키지 전용 가시성의 대안으로는 `internal`이라는 새로운 가시성 변경자를 도입하였다.

`internal`은 "모듈 내부에서만 몰 수 있음"을 의미한다.

모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에 있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근할 수 있으므로, 모듈의 캡슐화가 쉽게 깨질 수 있다.

차이점으로는 코틀린에서는 최상위 선언에 대해 `private` 가시성을 허용한다. (클래스, 함수, 프로퍼티 포함)


#### "코틀린의 가시성"

| 변경자             | 클래스 멤버              | 최상위 선언             |
|-----------------|---------------------|--------------------|
| public(default) | 모든 곳에서 볼 수 있다.      | 모든 곳에서 볼 수 있다.     |
| internal        | 같은 모듈 안에서만 볼 수 있다.  | 같은 모듈 안에서만 볼 수 있다. |
| protected       | 하위 클래스 안에서만 볼 수 있다. | 최상위 선언에 적용할 수 없음   |
| private         | 같은 클래스 안에서만 볼 수 있다. | 같은 파일 안에서만 볼 수 있다. |