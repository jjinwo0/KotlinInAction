# [기본 요소: 함수와 변수]

## 1. Hello, World!

```kotlin
fun main(args: Array<String>) {
    println("Hello, World!")
}
```

- 함수를 선언할 때 `fun` 키워드를 사용한다.
- 파라미터 이름 뒤에 파라미터의 타입을 사용한다.
- 함수를 최상위 수준에 정의할 수 있다.
  - Java와 달리 **꼭 클래스 안에 함수를 넣어야 할 필요가 없다.**
- Java와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- `System.out.println()` 대신 `println()`을 사용한다.
  - 코틀린 표준 라이브러리는 표준 Java 라이브러리 함수를 간결하게 사용할 수 있도록 감싼 Wrapper를 제공한다.
- 끝에 세미콜론을 붙이지 않아도 된다.

---

## 2. 함수
```kotlin
fun max(a: Int, b: Int): Int {
    return if(a > b) a else b
}

println(max(1, 2))
```

#### '문(statement)'과 '식(expression)'의 구분
> 코틀린에서 if는 **식이지 문이 아니다.**
> 
> 식은 **값을 만들어 내며** 다른 식의 **하위 요소로 계산에 참여할 수 있다.**
> 
> 반면 문은 **자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소**로 존재하며 **아무런 값을 만들어내지 않는다**는 차이가 있다.
> 
> Java에서는 모든 제어 구조가 **문**이지만, 코틀린에서는 루프를 제외한 대부분의 제어 구조가 **식**이다.
> 
> 반면 대입문은 Java에서는 식이였지만, 코틀린에서는 문이 되었다.
> 
> 이로 인해 Java와 달리 대입식과 비교식을 잘못 사용하여 버그가 생기는 일을 막는다.

### "식이 본문인 함수"

위의 함수를 더욱 간결하게 표현할 수 있다.
```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```
if는 **식**이므로 중괄호를 없애고 return을 제거하여 하나의 값으로 작용할 수 있다.

본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라 부르고,

등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 부른다.

반환 타입을 생략하여 더욱 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```
코틀린은 **정적 타입 지정 언어**이므로, 컴파일 시점에 모든 식의 타입을 지정해야 한다.

하지만 **어째서 반환 타입을 생략할 수 있는가?**

식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 **함수 본문 식을 분석**해 식의 결과 타입을 함수 반환 타입으로 정해준다.

#### 타입 추론 (Type Inference)
> 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능

## 3. 변수
Java의 경우 변수를 선언할 때 타입이 맨 앞에 온다.

반면 코틀린은 타입 지정을 생략하는 경우가 흔하다.

코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

```kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"

val answer = 42
```

해당 예제에 타입을 명시해도 이상 없다.

```kotlin
val question: String = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"

val answer: Int = 42
```

식이 본문인 함수에서와 마찬가지로 타입을 지정하지 않으면 컴파일러가 식을 분석하여 타입을 지정한다.

초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.

```kotlin
val answer: Int
answer = 42
```

초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다.

### "변경 가능한 변수와 변경 불가능한 변수"
- `val`
  - 값을 뜻하는 **'value'**에서 따옴
  - 변경 불가능한(immutable) 참조를 저장하는 변수다.
  - 일단 초기화하면 재대입이 불가능하다.
  - Java에서 `final` 키워드를 활용하는 것과 동일하다.
- `var`
  - 변수를 뜻하는 **'variable'**에서 따옴
  - 변경 가능한(mutable) 참조다.
  - Java의 일반 변수에 해당한다.

기본적으로 모든 변수를 `val` 키워드를 사용해 불변 변수로 선언하고,

나중에 꼭 필요할 때만 `var`로 변경하여

변경 불가능한 참조와 변경 불가능한 객체를

부수 효과가 없는 함수와 조합에 사용하면 코드가 **함수형 코드에 가까워진다.**

`val` 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.

하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면, 조건에 따라 `val`값을 다른 여러 값으로 초기화가 가능하다.

```kotlin
val message: String

if(canPerfoemOperation()) {
    message = "Success"
} else {
    message = "Failed"
}
```

---

## 4. 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
    val name = if(args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```

위 예제는 **문자열 템플릿(String Template)**이라는 기능을 보여준다.

`name`이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 변수를 사용했다.

코틀린에서도 변수를 문자열 안에 사용할 수 있다. -> `$` 키워드를 활용

`$` 키워드를 문자열에 넣고 싶으면 `println("\$x")`와 같이 \를 사용해 `$`를 이스케이프 시켜야 한다.

```kotlin
fun main(args: Array<String>) {
    println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}
```